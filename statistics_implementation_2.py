# -*- coding: utf-8 -*-
"""statistics_implementation-2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sKk1i0JFugEdixH8Tqmzg1CTmbY_LvUA
"""

data = [1, 2, 3, 4, 5]
data

import pandas as pd
import numpy as np
import seaborn as sns

#measures of central tendency
np.mean(data)

df = sns.load_dataset('tips')
df

np.mean(df['total_bill'])

df.describe()

data

np.median(data)

data = [1, 2, 3, 4, 500]

np.mean(data)

np.median(data)

#mean is inflated by outliers but median not

np.median(df['total_bill'])

data = [1, 2,3, 3, 3, 3, 4, 500]

data

np.mode(data)#this will throw error

import statistics
statistics.mode(data)

data

np.percentile(data, [25]) #25 percentage of the data is below 2.75

np.percentile(data, [25, 50, 75, 95, 96, 97, 98, 99, 100])

data

data.append(-500)

data = [1, 2, 3, 3, 3, 3, 4, 20, -20]

#outliers

sns.boxplot(data)

#measures of dispersion
data

np.var(data)

np.std(data)

statistics.variance(data) #sample variance (n-1)

statistics.pvariance(data) #population variance

import math
math.sqrt(statistics.variance(data))

data

len(data)

df

#how to know the relationship between two features
#correlation and covariance

df

corr = df[['total_bill', 'tip', 'size']].corr()

corr

df.corr(numeric_only = True)

#if there is one unit increase in total bill then there is 67 percent chance that tip will increase in tip

sns.heatmap(corr, annot = True)

df.cov(numeric_only = True)

sns.pairplot(df)

sns.histplot(data, kde = True)

sns.histplot(df['total_bill'], kde = True)

data1 = np.random.normal(0.5, 0.2, 1000)

sns.distplot(data1)

population = np.random.randint(10, 20, 50)

population

len(population)

statistics.mode(population)

np.mean(population)

sample1 = np.random.choice(population, 20)
sample2 = np.random.choice(population, 20)
sample3 = np.random.choice(population, 20)
sample4 = np.random.choice(population, 20)

sample1

sample2

mean_of_samples = []
all_samples = [sample1, sample2, sample3, sample4]

for sample in all_samples:
    mean_of_samples.append(np.mean(sample))

mean_of_samples

#central limit theorem >> for any distribution the sample mean will be approximated to normal distribution given sample size >= 30 and no of samples should be sufficiently large

population = np.random.binomial(10, 0.5, 10000)

population

sns.distplot(population)

sample_size = 3000

mean_of_samples = []

for i in range(1, 10000):
    sample = np.random.choice(population, size = sample_size)
    mean_of_samples.append(np.mean(sample))

sns.distplot(mean_of_samples, kde = True, color = 'red')

np.mean(mean_of_samples)

np.median(mean_of_samples)

statistics.mode(mean_of_samples)

#hence mean=median=mode


import scipy.stats as stats

mean_of_samples

z_critical = stats.norm.ppf(q = 0.975)
z_critical
#zcritical for give alpha, ztable

#t critical for give alpha, ttable
stats.t.ppf(df = 24, q = 0.97)

#margin of error
margin_of_error = z_critical * np.std(mean_of_samples) / np.sqrt(20)

margin_of_error

mean_of_samples

#confidence intervl
np.mean(mean_of_samples)-margin_of_error, np.mean(mean_of_samples)+margin_of_error

#Ztest
population = np.random.randn(1000)
population

sns.distplot(population)

np.mean(population), np.std(population)

null_mean = 0.05 #claim
#if pvalue <= 0.05 -- reject null hypothesis
#if p value > 0.05 -- fail to reject null hypothesis


from statsmodels.stats.weightstats import ztest

zscore, pvalue = ztest(population, value = null_mean, alternative = 'larger') #here alternative means, mean is greater than null mean

zscore

pvalue

if pvalue <= 0.05:
    print("Reject the H0")
else:
    print("fail to reject the H0")

"""#A school calculated iq scores of 50 students, the average iq  turned out to be 100. the mean of population iq is 90
#and the std deviation 16. \
#state whether the claim by school
#that IQ increases if student study more than avg of school with 5% of significance level

#null hypothesis : mean_iq = 90
#Alternate: mean_iq > 90
"""

#zcritical approach
import scipy.stats as stats

sample_mean = 100
population_mean = 90
population_std = 16
sample_size = 50
alpha = 0.05

zscore = (sample_mean - population_mean)/(population_std/np.sqrt(sample_size))

zscore

#stats module in scipy>>zcritical
#percent point function>>inverse of cdf
zcritical = stats.norm.ppf(1-alpha)

zcritical

if zscore >= zcritical:
    print("Reject the h0")
else:
    print("fail to reject the h0")

#pvalue approach using scipy

pvalue = 1-stats.norm.cdf(zscore)
pvalue

if pvalue <= alpha:
    print("Reject the H0")
else:
    print("Fail to reject H0")

#how to know if the given data is normally distributed or not
#distribution plot, q-q plot
#statistical test

data = pd.read_csv("https://raw.githubusercontent.com/shrikant-temburwar/Wine-Quality-Dataset/master/winequality-red.csv", sep = ";")

data

pop = np.random.randn(100000)
sns.distplot(pop)

from scipy import stats
stats.shapiro(population)

sns.distplot(data['citric acid'])

stats.shapiro(data['citric acid'])

"""#pvalue is less than 0.05 and hence reject the h0 that the sample is drawn from a normal dist population"""

#T test >> ss < 30 or sigma of pop is not given
#one sample t test (wrt one independent sample)
#two sample t test (wrt two independent sample)
#paired t test(two samples from same population from different time interval)

#one sample t test

population = np.random.randint(10, 50, 50)

population

sample = np.random.choice(population, 20)

np.mean(sample)

null_value = 25 #(the mean of population is 25)
import scipy
scipy.stats.ttest_1samp(sample, null_value)

#if pvalue>0.05, fail to reject the ho

#two sample t test

virat_kohli_score = np.random.choice(population, 20)

virat_kohli_score

rohit_sharma_score = [13, 25, 48, 28, 19, 12, 13, 18, 98, 40, 18, 23, 34, 33, 45, 58, 46, 27, 50, 49]

np.mean(rohit_sharma_score), np.mean(virat_kohli_score)

scipy.stats.ttest_ind(virat_kohli_score, rohit_sharma_score)

#if pvalue > 0.05, fail to reject the h0

#paired t test >> two sample from same population at different time interval

rohit_score_first_inning = [31, 36, 46, 24, 48, 46, 47, 47, 16, 35, 45, 37, 24, 29, 27, 42, 49, 37, 47, 46]
rohit_score_second_inning = [31, 76, 46, 24, 48, 23, 49, 47, 37, 35, 45, 37, 74, 39, 27, 42, 49, 37, 47, 46]

np.mean(rohit_score_first_inning), np.mean(rohit_score_second_inning)

scipy.stats.ttest_rel(rohit_score_first_inning, rohit_score_second_inning)

